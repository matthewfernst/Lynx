import heapq
from functools import reduce
import operator

def findEncryptedWord(s):
    # Write your code here
    res = ""

    def helper(st):
        nonlocal res
        if len(st) == 1:
            res += st
            return

        if len(st) == 0:
            return

        mid = (len(st) - 1) // 2
        res += st[mid]
        helper(st[:mid])
        helper(st[mid + 1:])
    helper(s)
    return res


def findPositions(arr, x):
    # Write your code here
    result = []
     # [1, 2, 2, 3, 4, 5] 
    arr = [[val, i + 1] for i, val in enumerate(arr)]
    for _ in range(x, 0, -1):
        popped = arr[:x] if len(arr) > x else arr
        arr = arr[x:] if len(arr) > x else []

        m = max(popped, key=lambda x: x[0])
        result.append(m[1])
        popped.remove(m)

        for i, val in enumerate(popped):
            if val[0] > 0:
                popped[i][0] -= 1
        arr += popped
    return result


def numberOfWays(arr, k):
  # Write your code here

  seen = {}
  num_pairs = 0
  for val in arr:
    comp = k - val
    if comp in seen:
      num_pairs += seen[comp]
    seen[val] = seen.get(val, 0) + 1
  return num_pairs


def findMaxProduct(arr):
  # Write your code here
  out = [-1, -1]
  heap = arr[:2]
  for i in range(2, len(arr), 1):
    heapq.heappush(heap, arr[i])
    out.append(
        reduce(
            operator.mul,
            heapq.nlargest(3, heap), 1)
    )
  return out


def count_subarrays(arr):
  # Write your code here

  res = [1]

  for i in range(1, len(arr), 1):
    total = 1
    left, right = i - 1, i + 1

    while left >= 0 and arr[i] > arr[left]:
      total += 1
      left -= 1

    while right < len(arr) and arr[i] > arr[right]:
      total += 1
      right += 1

    res.append(total)
  return res


print(count_subarrays([3, 4, 1, 6, 2]))
# print(findMaxProduct([1, 2, 3, 4, 5]))
# print(numberOfWays([1, 5, 3, 3, 3], 6))
# print(findPositions([1, 2, 2, 3, 4, 5], 5))
# print(findEncryptedWord("abc"))
